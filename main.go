package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/cybroslabs/gpg-encryptor/internal/service"
	_ "github.com/cybroslabs/gpg-encryptor/openapi" // openapi/swagger docs is generated by Swag CLI, you have to import it.
)

var version string = "dev"

//	@title			GPG Encryptor Service API
//	@version		1.0
//	@description	This is a small, lightweight service to encrypt and sign or just sign files using GPG.

//	@license.name	MIT
//	@license.url	https://github.com/cybroslabs/gpg-file-encryptor/blob/main/LICENSE

// @BasePath	/v1
func main() {
	server := &http.Server{
		Addr:         "0.0.0.0:8080",
		Handler:      service.Service(),
		ReadTimeout:  60 * time.Second,
		WriteTimeout: 60 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Server run context
	serverCtx, serverStopCtx := context.WithCancel(context.Background())

	// Listen for syscall signals for process to interrupt/quit
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

	// Graceful shutdown
	go func() {
		<-sigCh

		// Shutdown signal with grace period of 10 seconds
		shutdownCtx, shutdownCtxCancel := context.WithTimeout(serverCtx, 10*time.Second)
		defer shutdownCtxCancel()

		go func() {
			<-shutdownCtx.Done()
			if shutdownCtx.Err() == context.DeadlineExceeded {
				log.Fatal("graceful shutdown timed out.. forcing exit.")
			}
		}()

		// Trigger graceful shutdown
		log.Println("shutting down server...")
		err := server.Shutdown(shutdownCtx)
		if err != nil {
			log.Fatal(err)
		}
		serverStopCtx()
	}()

	// Run the server
	log.Println("starting gpg-encryptor server (version: " + version + ")on :8080 ...")
	err := server.ListenAndServe()
	if err != nil && err != http.ErrServerClosed {
		log.Fatal(err)
	}
	log.Println("server stopped")

	// Wait for server context to be stopped
	<-serverCtx.Done()
}
